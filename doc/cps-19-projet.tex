\documentclass{article}
\RequirePackage{dar}
%\RequirePackage[enseignants]{pc2r}
\usepackage{graphicx}
\lstset{language=c}
\usepackage{fullpage,url}
\usepackage[all]{xy}

\lstset{ basicstyle=\ttfamily\small, inputencoding=latin1, upquote=false,
  language=C, keywordstyle=\bfseries,
  identifierstyle=, % nothing happens
  commentstyle=\it\ttfamily, stringstyle=\ttfamily,
  showstringspaces=false %showstringspaces=true
}

\def\C{\lstset{language=C++}}
\def\JAVA{\lstset{language=Java}}
\def\OCAML{\lstset{language=[Objective]Caml}}

\renewcommand*{\ttdefault}{txtt}
\begin{document}

\authors{}
\titre{CPS 2019: Liens et Spécification partielle. \\ (version du 05/04/19)}

\entete{}

\section*{Liens}

{\small
  \begin{tabular}{ll}

Page \emph{Wikipedia} de \emph{Lode Runner} & \texttt{https://en.wikipedia.org/wiki/Lode\_Runner} \\
Vidéo \emph{Youtube} d'une partie de \emph{Lode Runner} & \texttt{https://www.youtube.com/watch?v=PWwyhymcDxI} \\
Interview du créateur du jeu & \texttt{https://www.retrogamer.net/retro\_games80/the-making-of-lode-runner/} \\
Jeu dans un navigateur & \texttt{http://loderunnerwebgame.com/game/} \\
Vidéo \emph{Youtube} d'un écran de \emph{Lode Runner 2} (en 3D)& 
  \texttt{https://www.youtube.com/watch?v=iMlhmiRCPO8}
\end{tabular}}

\section*{Spécification Partielle}

Cette spécification est une correction partielle du sujet d'examen
permettant de disposer d'une base commune pour le projet. Il n'est
absolument pas obligatoire de l'utiliser dans le projet, les
spécifications personnelles sont encouragées.

En découvrant des erreurs dans cette spécification, il convient de
contacter l'équipe pédagogique (ou d'en parler en TME) pour qu'elle
soit mise à jour.

\subsection*{Ecran}

\begin{tabular}{rl}
\textbf{Service}: & \textrm{Screen}  \\
\textbf{Observators}: & \textbf{const}~\texttt{Height}: \textrm{[Screen]} $\rightarrow$ \textrm{int} \\
& \textbf{const}~\texttt{Width}: \textrm{[Screen]} $\rightarrow$ \textrm{int} \\
& \texttt{CellNature}: \textrm{[Screen]} $\times$ \textrm{int} $\times$ \textrm{int} $\rightarrow$ \textrm{Cell} \\
& \quad \textbf{pre } \texttt{CellNature(S,x,y)} \textbf{ requires } 0 $\leq$ \texttt{y} $<$ \texttt{Height(S)} \textbf{ and } 0 $\leq$ \texttt{x} $<$ \texttt{Width(S)}\\
\textbf{Constructors}: & \texttt{init}: \textrm{int} $\times$ \textrm{int} $\rightarrow$ \textrm{[Screen]} \\
& \quad \textbf{pre } \texttt{init(h,w)} \textbf{ requires } 0 $<$ \texttt{h} \textbf{ and } 0 $<$ \texttt{w} \\
\textbf{Operators}: & \texttt{Dig}: \textrm{[Screen]} $\times$ \textrm{int} $\times$ \textrm{int}  $\rightarrow$ \textrm{[Screen]} \\
& \quad \textbf{pre } \texttt{Dig(S,x,y)} \textbf{ requires } \texttt{CellNature(S,x,y)} $=$ \textbf{PLT} \\
& \texttt{Fill}: \textrm{[Screen]} $\times$ \textrm{int} $\times$ \textrm{int}  $\rightarrow$ \textrm{[Screen]} \\
& \quad \textbf{pre } \texttt{Dig(S,x,y)} \textbf{ requires } \texttt{CellNature(S,x,y)} $=$ \textbf{HOL} \\
       \textbf{Observations}: & \\
       \texttt{[init]}: & \texttt{Height(init(h,w))} $=$ \texttt{h} \\
       & \texttt{Width(init(h,w))} $=$ \texttt{w} \\
       & \textbf{forall} $(x,y)$ \textbf{in} \texttt{[0;Width(S)[}$\times$ \texttt{[0;Height(S)[},~ \texttt{CellNature(init(h,w),x,y)} $=$ \textbf{EMP} \\
       \texttt{[Dig]}: & \texttt{CellNature(Dig(S,x,y)),x,y} $=$ \textbf{HOL} \\
        & \textbf{forall} $(x,y)$ \textbf{in} \texttt{[0;Width(S)[} $\times$ \texttt{[0;Height(S)[}, \\ & \quad\quad\quad\quad (\texttt{x} $\neq$ \texttt{u} \textbf{or} \texttt{y} $\neq$ \texttt{v}) \textbf{implies} \texttt{CellNature(Dig(S,u,v)),x,y)} $=$ \texttt{CellNature(x,y)} \\
       \texttt{[Fill]}: & \texttt{CellNature(Fill(S,x,y),x,y)} $=$ \textbf{PLT} \\
       & \textbf{forall} $(x,y)$ \textbf{in} \texttt{[0;Width(S)[}$\times$ \texttt{[0;Height(S)[}, \\ & \quad\quad\quad\quad (\texttt{x} $\neq$ \texttt{u} \textbf{or} \texttt{y} $\neq$ \texttt{v}) \textbf{implies} \texttt{CellNature(Fill(S,u,v)),x,y)} $=$ \texttt{CellNature(x,y)} \\
\end{tabular}

\subsection*{Ecran éditable}

\begin{tabular}{rl}
\textbf{Service}: & \textrm{EditableScreen} {\bf includes} \textrm{Screen}  \\
\textbf{Observators}: & \texttt{Playable}: \textrm{[EditableScreen]} $\rightarrow$ \textrm{bool} \\
\textbf{Operators}: & \texttt{SetNature}: \textrm{[EditableScreen]} $\times$ \textrm{int} $\times$ \textrm{int} $\times$ \textrm{Cell}  $\rightarrow$ \textrm{[EditableScreen]} \\
& \quad \textbf{pre } \texttt{SetNature(S,x,y,C)} \textbf{ requires } 0 $\leq$ \texttt{y} $<$ \texttt{Height(S)} \textbf{ and } 0 $\leq$ \texttt{x} $<$ \texttt{Width(S)}\\
\textbf{Observations}: \\
\texttt{[invariant]}: & \texttt{Playable(S)} \textbf{min} \\
& \quad\quad\quad\quad \textbf{forall} $(x,y)$ \textbf{in} \texttt{[0;Width(S)[}$\times$ \texttt{[0;Height(S)[}, \texttt{CellNature(S,x,y)} $\neq$ \textbf{HOL}  \\
& \quad\quad\quad\quad \textbf{and} \textbf{forall} $x$ \textbf{in} \texttt{[0;Width(S)[}, \texttt{CellNature(S,x,0)} $=$ \textbf{MTL}  \\
\texttt{[SetNature]}: & \texttt{CellNature(SetNature(S,x,y,C)),x,y} $=$ C \\
        & \textbf{forall} $(x,y)$ \textbf{in} \texttt{[0;Width(S)[}$\times$ \texttt{[0;Height(S)[}, \\ & \quad\quad\quad\quad (\texttt{x} $\neq$ \texttt{u} \textbf{or} \texttt{y} $\neq$ \texttt{v}) \textbf{implies} \texttt{CellNature(SetNature(S,u,v,C)),x,y)} $=$ \texttt{CellNature(x,y)} \\
\end{tabular}


\subsection*{Environnement}

\begin{tabular}{rl}
\textbf{Service}: & Environment \textbf{includes} Screen
\\ \textbf{Observators} : & \texttt{CellContent}:
\textrm{int} $\times$ \textrm{int} $\rightarrow$
\textrm{Set\{Character + Item\}} \\
& \quad \textbf{pre } \texttt{CellContent(E,x,y)} \textbf{ requires } 0 $\leq$ \texttt{y} $<$ \texttt{Height(S)} \textbf{ and } 0 $\leq$ \texttt{x} $<$ \texttt{Width(S)}\\
\textbf{Constructors}: & \texttt{init}: \textrm{EditableScreen} $\rightarrow$ \textrm{Environment} \\
\textbf{Observations}: \\
\texttt{[invariant]}: & \textbf{forall} $(\mathtt{x},\mathtt{y})$ \textbf{in} \texttt{[0;Width(E)[}$\times$ \texttt{[0;Height(E)[},~\\ & \quad\quad \textbf{forall} \textrm{Character} \texttt{c1}, \texttt{c2} \textbf{in} \texttt{CellContent(E,x,y)}$^2$, \texttt{c1} $=$ \texttt{c2} \\
& \textbf{forall} $(\mathtt{x},\mathtt{y})$ \textbf{in} \texttt{[0;Width(E)[}$\times$ \texttt{[0;Height(E)[},~\\ & \quad\quad \texttt{CellNature(E,x,y)} \textbf{in} \{\textbf{MTL}, \textbf{PLR}\} \textbf{implies} \texttt{CellContent(x,y)} $=$ $\emptyset$  \\
& \textbf{forall} $(\mathtt{x},\mathtt{y})$ \textbf{in} \texttt{[0;Width(E)[}$\times$ \texttt{[0;Height(E)[},~\\ & \quad\quad \textbf{exists} \textrm{Treasure} \texttt{t} \textbf{in} \texttt{CellContent(E,x,y)}  \\ & \quad\quad \textbf{implies} (\texttt{CellNature(E,x,y)} $=$ \textbf{EMP} \textbf{and} \texttt{CellNature(E,x,y-1)} \textbf{in} \{\textbf{PLT}, \textbf{MTL}\})\\
                        \texttt{[init]}: & \textbf{forall} $(\mathtt{x},\mathtt{y})$ \textbf{in} \texttt{[0;Width(E)[}$\times$ \texttt{[0;Height(E)[},~\\ & \quad\quad
                                \texttt{CellNature(init(S),x,y)} $=$ \textrm{EditableScreen}::\texttt{CellNature(S,x,y)} \\

                        
\end{tabular}

\subsection*{Personnage}

\begin{tabular}{rl}
\textbf{Service}: & \textrm{Character}  \\
\textbf{Observators}: & \textbf{const}~\texttt{Envi}: \textrm{[Character]} $\rightarrow$ \textrm{Environment}  \\
 & \texttt{Hgt}: \textrm{[Character]} $\rightarrow$ \textrm{int}  \\
 & \texttt{Wdt}: \textrm{[Character]} $\rightarrow$ \textrm{int}  \\
\textbf{Operators}: & \texttt{init}: \textrm{Screen} $\times$ \textrm{int} $\times$ \textrm{int} $\rightarrow$ \textrm{[Character]} \\
& \quad\textbf{pre} \textrm{init(S,x,y)} \textbf{requires} \textrm{Environment::CellNature(S,x,y)} $=$ \textbf{EMP} \\
& \texttt{GoLeft}: \textrm{[Character]} $\rightarrow$ \textrm{[Character]} \\
 & \texttt{GoRight}: \textrm{[Character]} $\rightarrow$ \textrm{[Character]} \\
 & \texttt{GoUp}: \textrm{[Character]} $\rightarrow$ \textrm{[Character]} \\
 & \texttt{GoDown}: \textrm{[Character]} $\rightarrow$ \textrm{[Character]} \\
\textbf{Observations}: \\
\texttt{[invariant]}: & \textrm{Environment::CellNature(Envi(C),Wdt(C),Hgt(C))} \textbf{in} \{\textbf{EMP}, \textbf{HOL}, \textbf{LAD}, \textbf{HDR}\} \\
& \textbf{exists} \textrm{Character} \texttt{x} \textbf{in} \textrm{Environment::CellContent(Envi(C),Wdt(C),Hgt(C))} \textbf{implies} \texttt{x} $=$ \texttt{C}  \\
\texttt{[GoLeft]}: & \textrm{Hgt(GoLeft(C))} $=$ \textrm{Hgt(C)} \\
& \textrm{Wdt(C)} $=$ 0 \textbf{implies} \textrm{Wdt(GoLeft(C))} = \textrm{Wdt(C)} \\
& \textrm{Environment::CellNature(Envi(C),Wdt(C)-1,Hgt(C))} \textbf{in} \{\textbf{MTL}, \textbf{PLT} \} \textbf{implies} \textrm{Wdt(GoLeft(C))} = \textrm{Wdt(C)} \\
& \textrm{Environment::CellNature(Envi(C),Wdt(C),Hgt(C))} \textbf{not in} \{\textbf{LAD}, \textbf{HDR}\}
\\ & \quad\quad \textbf{and} \textrm{Environment::CellNature(Envi(C),Wdt(C),Hgt(C)-1)} \textbf{not in} \{\textbf{PLT}, \textbf{MTL}, \textbf{LAD} \} \\
& \quad\quad \textbf{and} \textbf{not exists} \textrm{Character} c \textbf{in} \textrm{Environment::CellContent(Envi(C),Wdt(C),Hgt(C)-1)} \\
& \quad\quad \textbf{implies} \textrm{Wdt(GoLeft(C))} = \textrm{Wdt(C)} \\
& \textbf{exists} \textrm{Character} c \textbf{in} \textrm{Environment::CellContent(Envi(C),Wdt(C)-1,Hgt(C))} \\ & \quad\quad \textbf{implies} \textrm{Wdt(GoLeft(C))} = \textrm{Wdt(C)} \\
& (\textrm{Wdt(C)} $\neq$ 0) \textbf{and} \textrm{Environment::CellNature(Envi(C),Wdt(C)-1,Hgt(C))} \textbf{not in} \{\textbf{MTL}, \textbf{PLT} \} \\
& \quad\quad \textbf{and} (\textrm{Environment::CellNature(Envi(C),Wdt(C),Hgt(C))} \textbf{in} \{\textbf{LAD}, \textbf{HDR}\} \\
& \quad\quad\quad\quad \textbf{or} \textrm{Environment::CellNature(Envi(C),Wdt(C),Hgt(C)-1)} \textbf{in} \{\textbf{PLT}, \textbf{MTL}, \textbf{LAD}\} \\
& \quad\quad\quad\quad \textbf{or} \textbf{exists} \textrm{Character} c \textbf{in} \textrm{Environment::CellContent(Envi(C),Wdt(C),Hgt(C)-1)} ) \\
& \quad\quad \textbf{and} \textbf{not} (\textbf{exists} \textrm{Character} c \textbf{in} \textrm{Environment::CellContent(Envi(C),Wdt(C)-1,Hgt(C))}) \\
& \quad\quad \textbf{implies} \textrm{Wdt(GoLeft(C))} = \textrm{Wdt(C)}-1
\end{tabular}

\subsection*{Garde}

\begin{tabular}{rl}
\textbf{Service}: & \textrm{Guard} \textbf{includes} \textrm{Character}  \\
\textbf{Observators}: & \textbf{const} \texttt{Id}: \textrm{[Guard]} $\rightarrow$ \textrm{int}  \\
 & \texttt{Behaviour}: \textrm{[Guard]} $\rightarrow$ \textrm{Move}  \\
& \texttt{Target}: \textrm{[Guard]} $\rightarrow$ \textrm{Character}  \\
& \texttt{TimeInHole}: \textrm{[Guard]} $\rightarrow$ \textrm{int}  \\
\textbf{Operators}: & \texttt{ClimbLeft}: \textrm{[Guard]} $\rightarrow$ \textrm{[Guard]}\\
& \quad\quad \textbf{pre} \texttt{ClimbLeft(G)} \textbf{requires} \texttt{Environment::CellNature(Envi(G),Hgt(G),Wdt(G))} $=$ \textbf{HOL} \\
& \texttt{Step}: \textrm{[Guard]} $\rightarrow$ \textrm{[Guard]}\\
\textbf{Observations}: & \\
\textrm{[invariant]}: & \textrm{Environment::CellNature(Envi(G),Wdt(G),Hgt(G))} $=$ \textbf{LAD} \\
& \quad\quad \textbf{and} \textrm{Hgt(G)} $<$ \textrm{Character::Hgt(Target(G))} \\
& \quad\quad \textbf{and} (\textrm{Environment::CellNature(Envi(G),Wdt(G),Hgt(G)-1)} \textbf{not in} \{\textbf{PLT}, \textbf{MTL}  \} \\
& \quad\quad\quad\quad \textbf{or} \textbf{exists} \textrm{Character} c \textbf{in} \textrm{Environment::CellContent(Envi(G),Wdt(G),Hgt(G)-1)} \\
& \quad\quad\quad\quad \textbf{implies} \textrm{Environment::Hgt(Target(G)) - Hgt(G)} $<$ $|$\textrm{Environment::Wdt(Target(G)) - Wdt(G)})$|$)\\
& \quad\quad \textbf{implies} \textrm{Behaviour(G)} $=$ \textbf{Up} \\
& $(\dots)$ \\
\textrm{[init]}: & $(\dots)$ \\
\textrm{[ClimbLeft]}: 
& \textrm{Wdt(C)} $=$ 0 \textbf{implies} \textrm{Wdt(ClimbLeft(C))} = \textrm{Wdt(C)} \textbf{and} \textrm{Hgt(ClimbLeft(C))} $=$ \textrm{Hgt(C)} \\
& \textrm{Screen::CellNature(Envi(C),Wdt(C)-1,Hgt(C) +1)} \textbf{in} \{\textbf{MTL}, \textbf{PLT} \} \\ & \quad\quad \textbf{implies} \textrm{Wdt(ClimbLeft(C))} = \textrm{Wdt(C)} \textbf{and} \textrm{Hgt(ClimbLeft(C))} $=$ \textrm{Hgt(C)} \\
& \textbf{exists} \textrm{Character} c \textbf{in} \textrm{Environment::CellContent(Envi(C),Wdt(C)-1,Hgt(C)+1)} \\
& \quad\quad \textbf{implies} \textrm{Wdt(ClimbLeft(C))} = \textrm{Wdt(C)} \textbf{and} \textrm{Hgt(ClimbLeft(C))} $=$ \textrm{Hgt(C)} \\
& \textrm{Wdt(C)} $\neq$ 0 \textbf{and} \textrm{Screen::CellNature(Envi(C),Wdt(C)-1,Hgt(C)+1)} \textbf{notin} \{\textbf{MTL}, \textbf{PLT} \} \\
& \quad\quad \textbf{and} \textbf{not exists} \textrm{Character} c \textbf{in} \textrm{Environment::CellContent(Envi(C),Wdt(C)-1,Hgt(C)+1)} \\
& \quad\quad \textbf{implies} \textrm{Wdt(ClimbLeft(C))} = \textrm{Wdt(C)}-1 \textbf{and} \textrm{Hgt(ClimbLeft(C))} = \textrm{Hgt(C)}+1 \\
\textrm{[Step]}: & $(\dots)$ \\
& définir des prédicats et les réutiliser dans les gardes permet de rendre plus lisible la spécification, par exemple: \\
& \textbf{WillFall}\texttt{(C)} \textbf{defined by} (\textrm{Environment::CellNature(Envi(C),Wdt(C),Hgt(C)-1)} \textbf{in} \{\textbf{HOL}, \textbf{EMP} \}  \\
& \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \textbf{and} \textbf{not exists} \textrm{Character} c \textbf{in} \textrm{Environment::CellContent(Envi(C),Wdt(C),Hgt(C)-1)} \\
& \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \textbf{and} \textrm{Environment::CellNature(Envi(C),Wdt(C),Hgt(C))} \textbf{not in} \{\textbf{LAD}, \textbf{HDR} \} ) \\
& $(\dots)$
\end{tabular}


\end{document}


